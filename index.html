<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>NodeSpring by calbertts</title>

    <link href='https://fonts.googleapis.com/css?family=Noto+Sans' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">

    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 style="color: #329513">NodeSpring</h1>
        <h6 style="color: #A7A7A7">v0.0.13</h6>
        <p style="color: #A7A7A7">Dependency Injection for NodeJS using Javascript decorators</p>

        <div style="min-height: 450px;">
          <a href="#getStarted">Getting Started</a> <br/><br/>
          <a href="#controllers">Controllers</a> <br/>
          <a href="#decController">&nbsp;&nbsp; @Controller</a> <br/>
          <a href="#httpMethods">&nbsp;&nbsp;&nbsp;HTTP Methods</a> <br/><br/>

          <a href="#services">Services</a> <br/>
          <a href="#decService">&nbsp;&nbsp; @Service</a> <br/><br/>

          <a href="#dependencyInjection">Dependency Injection</a> <br/>
          <a href="#decInterface">&nbsp;&nbsp;&nbsp;@Interface</a> <br/>
          <a href="#decImplements">&nbsp;&nbsp;&nbsp;@Implements</a> <br/>
          <a href="#decInject">&nbsp;&nbsp;&nbsp;@Inject</a> <br/>
          <a href="#decPostInject">&nbsp;&nbsp;&nbsp;@PostInject</a> <br/><br/>

          <a href="#unitTesting">Unit Testing</a> <br/>
          <a href="#decTestClass">&nbsp;&nbsp;&nbsp;@TestClass</a> <br/>
          <a href="#decMock">&nbsp;&nbsp;&nbsp;@Mock</a> <br/>
          <a href="#decInjectMocks">&nbsp;&nbsp;&nbsp;@InjectMocks</a> <br/>
          <a href="#decBefore">&nbsp;&nbsp;&nbsp;@Before</a> <br/>
          <a href="#decTest">&nbsp;&nbsp;&nbsp;@Test</a> <br/>
        </div>
        <br />
        <p class="view"><a href="https://github.com/calbertts/nodespring">View the Project on GitHub <small>calbertts/nodespring</small></a></p>

        <ul>
          <li><a href="https://github.com/calbertts/nodespring/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/calbertts/nodespring/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/calbertts/nodespring">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
          <a id="getStarted" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Getting started
        </h3>
        <p>
          Start with <b>NodeSpring</b>, it's very easy:
        </p>

        <p>Installation:</p>

        <pre class="prettyprint lang-bash" style="padding: 15px; border: 1px solid #e5e5e5">$ npm install nodespring --save</pre>

        <p>
          The main file must be a class that inherits from <b>ExpressApp</b>:
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {ExpressApp} from 'nodespring'

export default class App extends ExpressApp {

  constructor() {
    super({
        port: 5000,
        classDir: __dirname,
        implConfig: {
          '/interfaces/DBService': './services/DBServiceImpl'
        }
    })
  }
}

new App().start()
</pre>
        <p>
          Using <i>Express</i> is optional, if you don't want to use it, you can create your own middleware
          extending from <b>NodeSpringApp</b>.
        </p>

        <p>
          <b>port:</b> The port where your server is going to run <br/>
          <b>classDir:</b> The directory where all your classes are placed <br/>
          <b>implConfig:</b> If you have several implementations for the same interface, would be necessary to define, which one of them is going<br/>
          to be used
        </p>

        <br/><br/>

        <h3>
          <a id="controllers" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Controllers
        </h3>

        <p>
          A Controller is a Javascript class where you define the end-points you have in your API.
          Controllers are used to handle the HTTP requests and call the service layer.
        </p>

        <h3>
        <a id="decController" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Controller
        </h3>

        <p>This decorator expects a class to be used as a Controller</p>
        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Controller} from 'nodespring'

@Controller
export default class MyController {

  // Methods to handle the HTTP requests
}</pre>

        <p>When you create a Controller, an URL is automatically created: <a href="#">http://localhost:8080/MyController</a></p>
        <p>If you want to change the name used in the URL, you can do:</p>
        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">
@Controller({path: 'users'})
export default class MyController {
  ...
}</pre>

        <p>Now we can access this controller in this way: <a href="#">http://localhost:8080/users</a></p>

        <br/><br/>

        <h3>
        <a id="httpMethods" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          HTTP Methods
        </h3>

        <p>
          Following, the decorators used to handle the common HTTP methods, they expect a method to be used as end-point and can be used only
          in a Controller class.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Controller, Post, Get} from 'nodespring'

@Controller
export default class MyController {

  @Get
  getMessage() {
    return "Message from MyController"
  }

  @Post
  getGreet(name) {
    return "Hi " + name
  }
}</pre>
        <p>Also if you want to return a JSON or any other kind of contentType, you can do:</p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">
@Post({contentType: 'application/json'})
getJSONObject(id, name) {
  return {
    id: id,
    userName: name
  }
}</pre>

        <p>Each method is an end-point: </p>
        <a href="#">http://localhost:8080/MyController/getMessage</a>
        <a href="#">http://localhost:8080/MyController/getJSONObject</a>

        <br/><br/>

        <p>Also, there are decorators to the other HTTP methods: </p>
        <p><b>&nbsp;&nbsp;&nbsp;&nbsp;@Put, @Delete, @Update</b></p>

        <br/><br/>

        <h3>
        <a id="services" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Services
        </h3>

        <p>
          A Service is a Javascript class where you define the methods to access a specific module of your application, let's understand
          a module as a unit on your business logic, don't think on NodeJS modules, let's assume that a module is a set of NodeJS modules which
          have a specific responsibility.
          <br/><br/>
          These modules usually need to communicate each other, but isn't a good practice to call directly a module from other one, it's preferable
          to have a Service layer where this communication is defined.
        </p>

        <h3>
        <a id="decService" class="anchor" href="#" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Service
        </h3>

        <p>
          This decoractor expects a class to be used as a Service, all the services are <b><i>singleton</i></b>, it means, only one instance
          of this class is going to be created and shared through all the application.
          <br/><br/>
          Each time a Service is <a href="#dependencyInjection">injected</a>, the unique instance is used, that's why all the Services
          must to be <i>stateless</i>.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Service} from 'nodespring'

@Service
export default class MyService {

  // Methods to communicate with the module
}</pre>

        <br/><br/>

        <h3>
          <a id="dependencyInjection" class="anchor" href="#dependencyInjection" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Dependency Injection
        </h3>

        <p>
          The Dependency Injection (DI) is a common pattern used in several frameworks, if you're a Java programmer and have worked with frameworks like Spring,
          you will miss some of those great features on NodeJS.

          <br/><br/>

          Yes, NodeJS is not Java, I'm not pretending to make it like that, but honestly, going through several DI frameworks for NodeJS, I found them too verbose and
          compilcated to understad, so that's why, taking advantage of the <i>decorators</i> which are an <b>experimental</b> feature on Javascript, I've created
          this to make things like DI easier.
        </p>

        <h3>
          <a id="decInterface" class="anchor" href="#decInterface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Interface
        </h3>

        <p>
          This decoractor expects a class to be used as an Interface. <br/>
          An Interface basically represents the shape of an object without specify its behavior, in this way, each time you need to use an object from
          that class, you aren't going to deal with a specific implementation of it, but with its interface. The only thing you need to know about that
          class is what it's offering, what are the methods you can use, the implementation details doesn't matter to other modules.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Interface} from 'nodespring'

@Interface
export default class DBService {

  saveEntity(entity) {}
  getEntityList(entityType) {}
}</pre>
        <p>
          As you notice, we are only specifying what are the methods that other modules will be able to use.
        </p>

        <h3>
          <a id="decImplements" class="anchor" href="#decImplements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Implements
        </h3>

        <p>
          This decoractor expects a class to be used as an Implementation. <br/>
          An Implementation is where you define the behaviour of a specific Interface, where all your third-party libraries are used.

          <br/><br/>

          Following, a dummy example what an implementation does:
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Implements} from 'nodespring'
import DBService from './DBService'

// Assuming you're using mongoose to create your models
import EntityModel from './models/EntityModel'


@Implements(DBService)
export default class DBServiceMongoDB {

  saveEntity(entity) {
    new EntityModel({
      id: '1',
      name: 'entity'
    }).save(() => {
      console.log('saved sucessfully!')
    })
  }

  deleteEntity(id) {
    EntityModel.find({id: id}).remove(() => {
      console.log('Removed!')
    })
  }
}</pre>

        <p>
          As you can see, all the details are here, if tomorrow we need to start using MySQL instead of MongoDB, the only thing we will need to do
          is to create another implementation of <b>DBService</b> and the other modules don't need to be aware about it because they
          <a href="#decInject">inject</a> using an interface and <b><i>NodeSpring</i></b> resolves which implementation has to be used.
        </p>

        <h3>
          <a id="decInject" class="anchor" href="#decInject" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Inject
        </h3>

        <p>
          This decorator expects an <a href="decInterface">Interface</a> as a parameter and it can be used only in class properties. <br/>
          This is the magic part, we are going to inject our <b>DBService</b> in <b>MyService</b> and make use of it.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {Service, Inject} from 'nodespring'
import DBService from './DBService'

@Service
export default class MyService {

  @Inject(DBService)
  dbService

  saveEntity() {
    let entity = {
      id: 1,
      name: 'entityName'
    }

    dbService.saveEntity(entity)
  }

  deleteEntity() {
    let id = 1

    dbService.deleteEntity(id)
  }
}</pre>
        <p>Here, you can notice that <b>MyService</b> doesn't know I'm using MongoDB, also, I'm not creating the instance directly:</p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5afac; background: #fff0eb">dbService = new DBServiceMongoDB()</pre>

        <p>
          Because in this way, I'd be creating a hard dependency between those classes and testing this class will be harder.
          <br/>
          Instead, I'm injecting using the interface and <b>NodeSpring</b> will resolve at runtime the implementation that needs to be used.
          <br/><br/>
          This resolves several problems, the first one is that our code is now decoupled, which is great,
          the other one is unit testing, I'll be able to mock all those interfaces providing fake implementations in order to test a specific
          implementation with real isolation.
          <br/><br/>
          Finally, all of this ends with a code easier to maintain and be modified by other programmers.
          <br/><br/>
          <b>There are some considerations about injecting dependencies:</b>
          <ul>
            <li>
              Implementations can be injected using the interface on Controllers, Services and other Implementations
            </li>
            <br/>
            <li>
              Services can be injected on Controllers, Implementations and other Services
            </li>
            <br/>
            <li>
              Controllers cannot be injected in other places, it supposed they are end-points, so it doesn't make sense thinking on inject them
            </li>
            <br/>
            <li>
              Controllers, Services and Implementations are <b>singleton</b> by default, it means, only one instance is going to be used during the application execution, it's
              supposed they are <i>stateless</i>.

              <br/><br/>
              With Implementations you can have several instances by using:
              <br/>
              <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">@Implements(DBService, Scope.PROTOTYPE)</pre>
              In this way, a new instance of the implementation is created each time the interface <b>DBService</b> is injected.
            </li>
          </ul>
        </p>

        <h3>
          <a id="decPostInject" class="anchor" href="#decPostInject" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @PostInject
        </h3>

        <p>
          This decorator expects a method to be executed once all the dependencies injected are resolved. <br/>
          Although you can use the <b><i>constructor</i></b> in each Javascript class, it's important to know that it's possible
          all the declared dependencies aren't resolved at the moment when the constructor is called, this is because all the dependencies are injected
          setting them in the instance which is being created.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {PostInject} from 'nodespring'

@PostInject
init() {
  // All the dependencies were injected
}
</pre>
        <br/><br/>

        <h3>
          <a id="unitTesting" class="anchor" href="#unitTesting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          Unit Testing
        </h3>

        <p>
          One of the good parts of using Dependency Injection is how easy is to test our code, the injection will allow us to isolate our code without pain.
          <br/><br/>
          You can mock the injected dependencies in each test, it allows you to define the way that a certain object behaves, this is pretty similar what you can do with Mockito in Java ecosystem.
        </p>

        <h3>
          <a id="decTestClass" class="anchor" href="#decTestClass" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @TestClass
        </h3>

        <p>
          This decorator expects an class as a parameter, it's basically to tell to NodeSpring that it's a <i>testing class</i> in order to prepare all the necessary stuff to execute each test.<br/>
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {TestClass} from 'nodespring'

@TestClass
export default class MyServiceTest {

  ...
}</pre>

        <h3>
          <a id="decMock" class="anchor" href="#decMock" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Mock
        </h3>

        <p>
          This decorator expects an <a href="#decInterface">Interface</a> as a parameter and it can be used only in class properties. <br/>
          Mocks an interface basically will assign a fake implementation that you can adjust during the test in order to isolate the code you're testing.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {TestClass, Mock} from 'nodespring'
import DBService from './DBService'

@TestClass
export default class MyServiceTest {

  @Mock(DBService)
  dbServiceMock

  ...
}</pre>

        <h3>
          <a id="decInjectMocks" class="anchor" href="#decInjectMocks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @InjectMocks
        </h3>

        <p>
          This decorator expects an <a href="#decInterface">Interface</a> as a parameter and it can be used only in class properties. <br/>
          When you're testing, you have basically two things: the dependencies and the class you want to test.
          <br/><br/>
          Once, you have mocked all the dependencies, you will need to inject those fake implementations in the real object you're gonna test.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {TestClass, Mock, InjectMocks} from 'nodespring'
import DBService from './DBService'
import MyService from './MyService'

@TestClass
export default class MyServiceTest {

  @Mock(DBService)
  dbServiceMock

  @InjectMocks(MyService)
  myService

  ...
}</pre>

        <h3>
          <a id="decBefore" class="anchor" href="#decBefore" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Before
        </h3>

        <p>
          This decorator expects a method as a parameter.
          <br/><br/>
          Sometimes, it's necessary to prepare objects or data before to run each test, but remember, those tests should be stateless, it means, you have to prepare all you need for each test in a separate way, they shouldn't depend on any other test.
          This is essentially because you can have asynchronous operations inside of the class you're testing, it means, you cannot guarantee in which order the tests
          are going to finish.
          <br/><br/>
          This method decorated with @Before is executed just before to call each test, so, if you have three tests, the <i>before</i> method is execute three times.
          This is useful when you need to prepare something that is common to all the tests just before to start.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {TestClass, Mock, InjectMocks} from 'nodespring'
import DBService from './DBService'
import MyService from './MyService'

@TestClass
export default class MyServiceTest {

  @Mock(DBService)
  dbServiceMock

  @InjectMocks(MyService)
  myService

  @Before
  initTest() {
    // stuff before test
  }
}</pre>

        <h3>
          <a id="decTest" class="anchor" href="#decTest" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>
          @Test
        </h3>

        <p>
          This decorator expects a method as a parameter.
          <br/><br/>
          Each method that is a test, must be decorated with this, otherwise, it isn't going to be called, unless you call it from a test method.
          <br/><br/>
          Additionally, each test method will receive an <i>assert</i> object, that is basically an instance of the great npm package:
          <a href="https://www.npmjs.com/package/assert">assert</a>.
          <br/><br/>
          In order to support asynchronous testing, there's an additional method that you can call when your test is completed: <i>assert.done()</i>.
        </p>

        <pre class="prettyprint lang-js" style="padding: 15px; border: 1px solid #e5e5e5">import {TestClass, Mock, InjectMocks} from 'nodespring'
import DBService from './DBService'
import MyService from './MyService'

@TestClass
export default class MyServiceTest {

  @Mock(DBService)
  dbServiceMock

  @InjectMocks(MyService)
  myService

  @Before
  initTest() {
    // stuff before test
  }

  @Test
  test1(assert) {
    this.dbServiceMock.saveEntity = (entityType, entity) => {

      // Simulating async behavior
      setTimeout(() => {

        // You can use all the methods in "assert" npm package
        assert.equal(true, true)

        // Call done() method to finish the current test like in NodeUnit
        assert.done()
      }, 5000)
    }
  }
}</pre>

        <br/><br/>

        Hope you find <b>NodeSpring</b> useful, this is in an early stage, but it's functional.
        All kind of PRs are welcome, even with this docs, my english is still in progress ;)

      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/calbertts">calbertts</a></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-74157601-1");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </body>
</html>
