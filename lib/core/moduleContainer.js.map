{"version":3,"sources":["../../src/core/ModuleContainer.js"],"names":[],"mappings":"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","file":"ModuleContainer.js","sourcesContent":["/**\n * ModuleContainer\n * @author calbertts\n *\n * This class handles all the stuff relates with:\n *\n *    Controllers and HTTP methods\n *    Dependency Injection\n */\n\nimport fs from 'fs'\nimport path_module from 'path'\nimport NodeSpringUtil from './nodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\n\n\nglobal.modulesContainer = {}\nlet modulesContainer = global.modulesContainer\n\nexport default class ModuleContainer {\n\n  static appDir = null\n  static implConfig = {}\n  static nodeSpringApp = {\n    bindURL: () => {},\n    addSocketListener: () => {}\n  }\n\n  static init(appDir, nodeSpringApp, implConfig, logging = false, loggingSync = false, debugging = false) {\n    NodeSpringUtil.logging = logging\n    NodeSpringUtil.configureLoggingOut(loggingSync)\n    NodeSpringUtil.debugging = debugging\n\n    ModuleContainer.appDir = appDir\n    ModuleContainer.implConfig = implConfig\n    ModuleContainer.nodeSpringApp = nodeSpringApp\n  }\n\n  static loadModules() {\n    let load = (path) => {\n      try {\n        let stat = fs.lstatSync(path)\n\n        if (stat.isDirectory()) {\n          let files = fs.readdirSync(path)\n          let f, l = files.length\n          for (let i = 0; i<l; i++) {\n            f = path_module.join(path, files[i])\n            load(f)\n          }\n        } else {\n          if(path.indexOf('.map') < 0) {\n            require(path)\n            console.log(\"Loading file => \" + path)\n          }\n        }\n      } catch(e) {\n        throw new NodeSpringException(e.message, this)\n      }\n    }\n\n    let baseDir = path_module.join(ModuleContainer.appDir)\n    load(baseDir)\n\n    // All metadata is loaded except the injected instances\n    ModuleContainer.nodeSpringApp.configureSocketListeners()\n  }\n\n  static addService(moduleDef) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.runInjectionResolver(moduleName)\n  }\n\n  static addController(moduleDef, path) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].path = path\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.runInjectionResolver(moduleName)\n\n    let moduleInfo = modulesContainer[moduleName]\n\n    let processRequest = (req, res, methodInfo) => {\n      let fn = moduleInfo.impl[methodInfo.methodName]\n\n      ModuleContainer.nodeSpringApp.getRequestParams(req, (params) => {\n        let fullParams = NodeSpringUtil.getArgs(fn).map((item, index) => {\n          return params[item] || (params[item + '[]'] instanceof Array ? params[item + '[]'] : [params[item + '[]']])\n        })\n\n        let handleResponse = (data) => {\n          ModuleContainer.nodeSpringApp.setContentTypeResponse(res, methodInfo.contentType)\n\n          if(methodInfo.contentType === 'application/json') {\n            ModuleContainer.nodeSpringApp.sendJSONResponse(res, data)\n          } else {\n            ModuleContainer.nodeSpringApp.sendDataResponse(res, data)\n          }\n        }\n\n        // Getting method response\n        fn.request = req\n        fn.response = res\n        let value = fn.apply(moduleInfo.impl, fullParams)\n\n        // Clear\n        delete fn.request\n        delete fn.response\n\n        if(value !== undefined) {\n          if(value instanceof Promise) {\n            value\n              .then((data) => {\n                handleResponse(data)\n              })\n              .catch((err) => {\n                handleResponse([])\n              })\n          } else {\n            handleResponse(value)\n          }\n        }\n      })\n    }\n\n    /**\n     * This metadata is created in addSocketListener method\n     */\n    moduleInfo.socketListeners.forEach((socketListenerData) => {\n      ModuleContainer.nodeSpringApp.addSocketListener(socketListenerData, moduleInfo.impl)\n    })\n\n    // Bind index method\n    ModuleContainer.nodeSpringApp.bindURL('get', `/${path}`, (req, res) => {\n      processRequest(req, res, {methodName: 'index'})\n    })\n\n    // Bind the other endpoints\n    moduleInfo.methods.forEach((methodInfo) => {\n      ModuleContainer.nodeSpringApp.bindURL(methodInfo.httpMethod, `/${path}/${methodInfo.methodName}`, (req, res) => {\n        processRequest(req, res, methodInfo)\n      })\n    })\n  }\n\n  static addRoute(moduleDef, methodName, httpMethod, contentType) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n\n    modulesContainer[moduleName].methods.push({\n      methodName: methodName,\n      httpMethod: httpMethod,\n      contentType: contentType\n    })\n  }\n\n  static addSocketListener(moduleDef, methodName, options) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n\n    modulesContainer[moduleName].socketListeners.push({\n      methodName: methodName,\n      namespace: options.namespace ? options.namespace : '/',\n      eventName: options.eventName ? options.eventName : methodName\n    })\n  }\n\n  static validateImpl(type, impl) {\n    ModuleContainer.addInterface(type.packagePath)\n\n    let interfaceMethods = Object.getOwnPropertyNames(type.prototype)\n    let implementationMethods = Object.getOwnPropertyNames(impl.prototype)\n\n    interfaceMethods.filter((methodName) => {\n      return methodName !== 'constructor'\n    }).forEach(methodName => {\n      let isMethodImplemented = implementationMethods.indexOf(methodName) >= 0\n\n      if (!isMethodImplemented) {\n        let errorMessage = `The method \"${methodName}\" declared in ${type.packagePath} is not implemented in ${impl.name}`\n        let methodNotImplemented = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n        NodeSpringUtil.throwNodeSpringException(methodNotImplemented)\n      } else {\n        NodeSpringUtil.getArgs(type.prototype[methodName]).forEach((param) => {\n          let implMethodParams = NodeSpringUtil.getArgs(impl.prototype[methodName])\n          let isParamPresent = implMethodParams.indexOf(param) >= 0\n\n          if (!isParamPresent) {\n            let errorMessage = `The param \"${param}\" declared in ${type.packagePath}.${methodName}(...) is not present in ${impl.name}.${methodName}(...)`\n            let missingParam = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n            NodeSpringUtil.throwNodeSpringException(missingParam)\n          }\n        })\n      }\n    })\n\n    return true\n  }\n\n  static addInterface(type) {\n    if (!ModuleContainer.existsInterface(type)) {\n      modulesContainer[type] = {\n        impl: null,\n        dependents: {},\n        dependencies: {},\n        methods: [],\n        socketListeners: [],\n        instanceResolvedValue: false,\n        isInstanceResolved: () => {\n          if(modulesContainer[type].moduleType === 'service' || modulesContainer[type].moduleType === 'controller') {\n            return modulesContainer[type].impl !== null\n          } else {\n            return modulesContainer[type].instanceResolvedValue\n          }\n        },\n        getInstance: () => {\n          /*if(modulesContainer[type].moduleType === 'service' || modulesContainer[type].moduleType === 'controller') {\n            return new Promise((resolve, reject) => {\n              resolve(modulesContainer[type].impl)\n            })\n          } else {*/\n            let moduleInfo = modulesContainer[type]\n            let dependencies = moduleInfo.dependencies\n\n            NodeSpringUtil.debug('getInstance for an Impl', type, dependencies)\n\n            if (Object.keys(dependencies).length > 0) {\n              NodeSpringUtil.debug('has dependencies')\n\n              let dependenciesInstancesPromises = []\n              let mapImplVariable = {}\n\n              for(let property in dependencies) {\n                let moduleNeeded = dependencies[property]\n\n                let promise = modulesContainer[moduleNeeded].getInstance()\n\n                mapImplVariable[moduleNeeded] = property\n\n                dependenciesInstancesPromises.push(promise)\n              }\n\n              let mainPromise = new Promise((resolve, reject) => {\n\n                /**\n                 * Wait for the dependencies are resolved to be injected\n                 * in the instance that's being created\n                 */\n                /*Promise.all(dependenciesInstancesPromises).then((instances) => {\n                  NodeSpringUtil.debug('another listener')\n                })*/\n\n                Promise.all(dependenciesInstancesPromises).then((instances) => {\n                  NodeSpringUtil.debug('official promises resolved')\n\n                  //console.log('official promises resolved')\n\n                  //NodeSpringUtil.error('Promise scope', type, modulesContainer[type].scope)\n                  let mainInstance = modulesContainer[type].impl.scope === 'prototype' ? new modulesContainer[type].impl() : modulesContainer[type].impl\n\n                  instances.forEach((instanceToInject) => {\n                    //console.log('instanceToInject', instanceToInject)\n\n                    let varType = instanceToInject.constructor.interfacePackagePath\n                    let property = mapImplVariable[varType]\n\n                    mainInstance[property] = instanceToInject\n                  })\n\n                  // Call the init method once all the dependencies are created and injected\n                  let postInjectMethod = modulesContainer[type].postInjectMethod\n\n                  if(postInjectMethod) {\n                    //console.log('type', type, postInjectMethod)\n                    mainInstance[postInjectMethod]()\n                  }\n\n                  // Resolve the complete instance to the modules which are waiting for it\n                  resolve(mainInstance)\n                }).catch((err) => {\n                  NodeSpringUtil.error('Error resolving instance for', type, err)\n                })\n              })\n\n              return mainPromise\n            } else {\n\n              //NodeSpringUtil.debug('return instance without dependencies', type)\n\n              /**\n               * If the module doesn't have dependencies, returns the impl if it's loaded or\n               * will wait for the implementation that is loaded to dispatch the instance.\n               */\n              return new Promise((resolve, reject) => {\n                if(modulesContainer[type].impl) {\n                  NodeSpringUtil.debug('No dependencies, instance resolved')\n                  modulesContainer[type].instanceResolvedValue = true\n\n                  if(modulesContainer[type].impl.scope) {\n                    if(modulesContainer[type].impl.scope === 'singleton')\n                      resolve(modulesContainer[type].impl)\n                    else if(modulesContainer[type].impl.scope === 'prototype')\n                      resolve(new modulesContainer[type].impl())\n                  } else {\n                    resolve(modulesContainer[type].impl)\n                  }\n                  //resolve(!modulesContainer[type].impl.scope ? modulesContainer[type].impl : new modulesContainer[type].impl())\n                } else {\n                  NodeSpringUtil.debug('No dependencies, observing for impl to be resolved')\n\n                  Object.observe(modulesContainer[type], (changes) => {\n                    NodeSpringUtil.debug('impl arrived', type)\n\n                    let change = changes.filter((change) => change.type === 'update')[0]\n\n                    modulesContainer[type].instanceResolvedValue = true\n                    resolve(!modulesContainer[type].impl.scope ? modulesContainer[type].impl : new modulesContainer[type].impl())\n                  })\n                }\n              })\n            }\n          //}\n        },\n        injectDependency: (property, impl) => {\n          modulesContainer[type].impl[property] = impl\n        }\n      }\n    }\n  }\n\n  static existsInterface(type) {\n    return modulesContainer[type] !== undefined\n  }\n\n  static resolveDependencies(type, dependencies) {\n    for(let property in dependencies) {\n      let expectedType = dependencies[property]\n\n      NodeSpringUtil.debug('expectedType', expectedType)\n\n      if(ModuleContainer.existsInterface(expectedType) && modulesContainer[expectedType].isInstanceResolved()) {\n        //NodeSpringUtil.debug('exist!')\n\n        modulesContainer[expectedType].getInstance().then((instance) => {\n          //NodeSpringUtil.debug('promise resolved:', instance)\n          modulesContainer[type].injectDependency(property, instance)\n\n          let targetInstanceName = modulesContainer[type].impl.scope ? modulesContainer[type].impl.name : modulesContainer[type].impl.constructor.name\n          NodeSpringUtil.log('Dispatching an instance of ', modulesContainer[expectedType].impl.constructor.name, ' for ', targetInstanceName + '.' + property)\n        })\n      } else {\n        NodeSpringUtil.debug('doesnt exist!')\n        if(!ModuleContainer.existsInterface(expectedType)) {\n          NodeSpringUtil.debug('creating!')\n          ModuleContainer.addInterface(expectedType)\n        }\n\n        //NodeSpringUtil.debug('modulesContainer[expectedType]', modulesContainer[expectedType])\n\n        let myOwnDependents = modulesContainer[expectedType].dependents[type] = {}\n\n        myOwnDependents[property] = {\n          dispatched: false,\n          callback: (instance) => {\n            NodeSpringUtil.debug(\"I'm here!\", instance)\n            modulesContainer[type].injectDependency(property, instance)\n\n            let targetInstanceName = modulesContainer[type].impl.scope ? modulesContainer[type].impl.name : modulesContainer[type].impl.constructor.name\n            NodeSpringUtil.log('Dispatching an instance of ', instance.constructor.name, ' for ', targetInstanceName + '.' + property)\n          }\n        }\n      }\n    }\n  }\n\n  static dispatchDependents(type, dependents) {\n    for(let className in dependents) {\n      let classProperties = dependents[className]\n\n      for(let property in classProperties) {\n        let resolverCallbackInfo = classProperties[property]\n\n        modulesContainer[type].getInstance().then((instance) => {\n          if(!resolverCallbackInfo.dispatched) {\n            resolverCallbackInfo.callback(instance)\n            resolverCallbackInfo.dispatched = true\n          }\n        }).catch((err) => {\n          NodeSpringUtil.error('Error dispatching instance for the property', property)\n        })\n      }\n    }\n  }\n\n  static runInjectionResolver(type) {\n\n    //NodeSpringUtil.debug('type, modulesContainer[type].dependencies', type, modulesContainer[type].dependencies)\n\n    // Resolve dependencies\n    ModuleContainer.resolveDependencies(type, modulesContainer[type].dependencies)\n\n    // Dispatch registered dependents\n    ModuleContainer.dispatchDependents(type, modulesContainer[type].dependents)\n\n    // Wait and dispatch for future dependents to be resolved\n    Object.observe(modulesContainer[type].dependents, (changes) => {\n      ModuleContainer.dispatchDependents(type, modulesContainer[type].dependents)\n    })\n  }\n\n  static addDependency(type, property, typeToInject) {\n    ModuleContainer.addInterface(type)\n    modulesContainer[type].dependencies[property] = typeToInject.packagePath\n  }\n\n  static addImplementation(type, impl) {\n    if(ModuleContainer.validateImpl(type, impl)) {\n      modulesContainer[type.packagePath].impl = (impl.scope === 'prototype') ? impl : new impl()\n      ModuleContainer.runInjectionResolver(type.packagePath)\n    }\n  }\n\n  static addPostInjectMethod(type, methodName) {\n    modulesContainer[type].postInjectMethod = methodName\n  }\n\n  static getModuleContainer() {\n    return modulesContainer\n  }\n\n  static clearModuleContainer() {\n    modulesContainer = {}\n  }\n}\n"]}