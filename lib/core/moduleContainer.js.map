{"version":3,"sources":["../../src/core/ModuleContainer.js"],"names":[],"mappings":"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","file":"ModuleContainer.js","sourcesContent":["/**\n * ModuleContainer\n * @author calbertts\n *\n * This class handles all the stuff relates with:\n *\n *    Controllers and HTTP methods\n *    Dependency Injection\n */\n\nimport fs from 'fs'\nimport path_module from 'path'\nimport NodeSpringUtil from './nodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\n\n// The unique module container\nglobal.modulesContainer = {}\nvar modulesContainer = global.modulesContainer\n\n\nexport default class ModuleContainer {\n\n  NodeSpringApp = null\n\n  static init(app, appDir) {\n    //NodeSpringUtil.configureLoggingOut()\n    ModuleContainer.NodeSpringApp = app\n  }\n\n  static loadModules(appDir) {\n    let load = (path) => {\n      fs.lstat(path, (err, stat) => {\n        if(err)\n          throw err\n        else if (stat.isDirectory()) {\n          fs.readdir(path, (err, files) => {\n            let f, l = files.length\n            for (let i = 0; i < l; i++) {\n              f = path_module.join(path, files[i])\n              load(f)\n            }\n          })\n        } else {\n          if(path.indexOf('.map') < 0) {\n            //console.log(\"Loading file => \" + path)\n            require(path).default\n          }\n        }\n      })\n    }\n\n    let baseDir = path_module.join(appDir)\n    load(baseDir)\n  }\n\n  static addService(moduleDef) {\n    let moduleName = moduleDef.name\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.runInjectionResolver(moduleName)\n  }\n\n  static addController(moduleDef, path) {\n    let moduleName = moduleDef.name\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].path = path\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.runInjectionResolver(moduleName)\n\n    let moduleInfo = modulesContainer[moduleName]\n    let publishedURLs = []\n\n    for(let i=0; i<moduleInfo.methods.length; i++) {\n      let methodInfo = moduleInfo.methods[i]\n\n      publishedURLs.push(`/${path}/${methodInfo.methodName}`)\n\n      ModuleContainer.NodeSpringApp.bindURL(methodInfo.httpMethod, `/${path}/${methodInfo.methodName}`, (req, res) => {\n        let fn = moduleInfo.impl[methodInfo.methodName]\n\n        ModuleContainer.NodeSpringApp.getRequestParams(req, (params) => {\n          let fullParams = NodeSpringUtil.getArgs(fn).map((item, index) => {\n            return params[item] || (params[item + '[]'] instanceof Array ? params[item + '[]'] : [params[item + '[]']])\n          })\n\n          let handleResponse = (data) => {\n            ModuleContainer.NodeSpringApp.setContentTypeResponse(res, methodInfo.contentType)\n\n            if(methodInfo.contentType === 'application/json') {\n              ModuleContainer.NodeSpringApp.sendJSONResponse(res, data)\n            } else {\n              ModuleContainer.NodeSpringApp.sendDataResponse(res, data)\n            }\n          }\n\n          // Getting method response\n          let value = fn.apply(moduleInfo.impl, fullParams)\n\n          if(value instanceof Promise) {\n            value\n              .then((data) => {\n                handleResponse(data)\n              })\n              .catch((err) => {\n                handleResponse([])\n              })\n          } else {\n            handleResponse(value)\n          }\n        })\n      })\n    }\n  }\n\n  static addRoute(moduleDef, methodName, httpMethod, contentType) {\n    let moduleName = moduleDef.constructor.name\n\n    ModuleContainer.addInterface(moduleName)\n\n    modulesContainer[moduleName].methods.push({\n      methodName: methodName,\n      httpMethod: httpMethod,\n      contentType: contentType\n    })\n  }\n\n  static validateImpl(type, impl) {\n    ModuleContainer.addInterface(type.name)\n\n    //if(!modulesContainer[type.name].impl) {\n      let interfaceMethods = Object.getOwnPropertyNames(type.prototype)\n      let implementationMethods = Object.getOwnPropertyNames(impl.prototype)\n\n      interfaceMethods.filter((methodName) => {\n        return methodName !== 'constructor'\n      }).forEach(methodName => {\n        let isMethodImplemented = implementationMethods.indexOf(methodName) >= 0\n\n        if (!isMethodImplemented) {\n          let errorMessage = `The method \"${methodName}\" declared in ${type.name} is not implemented in ${impl.name}`\n          let methodNotImplemented = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n          NodeSpringUtil.throwNodeSpringException(methodNotImplemented)\n        } else {\n          NodeSpringUtil.getArgs(type.prototype[methodName]).forEach((param) => {\n            let implMethodParams = NodeSpringUtil.getArgs(impl.prototype[methodName])\n            let isParamPresent = implMethodParams.indexOf(param) >= 0\n\n            if (!isParamPresent) {\n              let errorMessage = `The param \"${param}\" declared in ${type.name}.${methodName}(...) is not present in ${impl.name}.${methodName}(...)`\n              let missingParam = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n              NodeSpringUtil.throwNodeSpringException(missingParam)\n            }\n          })\n        }\n      })\n\n      return true\n    /*} else {\n      console.error(`NodeSpring Error: \\nThere are more than one implementations associated with the Interface: ${type.name}\\nThe current implementation is: ${modulesContainer[type.name].name}\\nPlease review the class: ${impl.name}, the Interfaces must only have one implementation\\n`)\n      return false\n    }*/\n  }\n\n  static addInterface(type) {\n    if (!ModuleContainer.existsInterface(type)) {\n      modulesContainer[type] = {\n        impl: null,\n        dependents: {},\n        dependencies: {},\n        structure: {},\n        methods: [],\n        instanceResolvedValue: false,\n        isInstanceResolved: () => {\n          if(modulesContainer[type].moduleType === 'service' || modulesContainer[type].moduleType === 'controller') {\n            return modulesContainer[type].impl !== null\n          } else {\n            return modulesContainer[type].instanceResolvedValue\n          }\n        },\n        getInstance: () => {\n          if(modulesContainer[type].moduleType === 'service' || modulesContainer[type].moduleType === 'controller') {\n            return new Promise((resolve, reject) => {\n              resolve(modulesContainer[type].impl)\n            })\n          } else {\n            let moduleInfo = modulesContainer[type]\n            let dependencies = moduleInfo.dependencies\n\n            if (Object.keys(dependencies).length > 0) {\n              let dependenciesInstancesPromises = []\n              let mapImplVariable = {}\n\n              for(let property in dependencies) {\n                let moduleNeeded = dependencies[property]\n\n                let promise = modulesContainer[moduleNeeded].getInstance()\n\n                mapImplVariable[moduleNeeded] = property\n\n                dependenciesInstancesPromises.push(promise)\n              }\n\n              return new Promise((resolve, reject) => {\n\n                /**\n                 * Wait for the dependencies are resolved to be injected\n                 * in the instance that's being created\n                 */\n                Promise.all(dependenciesInstancesPromises).then((instances) => {\n                  //console.error('Promise scope', type, modulesContainer[type].scope)\n                  let mainInstance = modulesContainer[type].impl.scope === 'prototype' ? new modulesContainer[type].impl() : modulesContainer[type].impl\n\n                  instances.forEach((instanceToInject) => {\n                    let varType = instanceToInject.constructor.interfaceName\n                    let property = mapImplVariable[varType]\n\n                    mainInstance[property] = instanceToInject\n                  })\n\n                  // Call the init method once all the dependencies are created and injected\n                  let postInjectMethod = modulesContainer[type].postInjectMethod\n\n                  if(postInjectMethod) {\n                    mainInstance[postInjectMethod]()\n                  }\n\n                  // Resolve the complete instance to the modules which are waiting for it\n                  resolve(mainInstance)\n                }).catch((err) => {\n                  console.error('Error resolving instance for', type, err)\n                })\n              })\n            } else {\n\n              /**\n               * If the module doesn't have dependencies, will wait for the implementation\n               * is loaded to dispatch the instance.\n               */\n              return new Promise((resolve, reject) => {\n                Object.observe(modulesContainer[type], (changes) => {\n                  let change = changes.filter((change) => change.type === 'update')[0]\n\n                  modulesContainer[type].instanceResolvedValue = true\n                  resolve(!modulesContainer[type].impl.scope ? modulesContainer[type].impl : new modulesContainer[type].impl())\n                })\n              })\n            }\n          }\n        },\n        injectDependency: (property, impl) => {\n          modulesContainer[type].impl[property] = impl\n        }\n      }\n    }\n  }\n\n  static existsInterface(type) {\n    return modulesContainer[type] !== undefined\n  }\n\n  static resolveDependencies(type, dependencies) {\n    for(let property in dependencies) {\n      let expectedType = dependencies[property]\n\n      if(ModuleContainer.existsInterface(expectedType) && modulesContainer[expectedType].isInstanceResolved()) {\n        modulesContainer[expectedType].getInstance().then((instance) => {\n          modulesContainer[type].injectDependency(property, instance)\n\n          let targetInstanceName = modulesContainer[type].impl.scope ? modulesContainer[type].impl.name : modulesContainer[type].impl.constructor.name\n          console.log('Dispatching an instance of ', modulesContainer[expectedType].impl.constructor.name, ' for ', targetInstanceName + '.' + property)\n        })\n      } else {\n        if(!ModuleContainer.existsInterface(expectedType)) {\n          ModuleContainer.addInterface(expectedType)\n        }\n\n        let myOwnDependents = modulesContainer[expectedType].dependents[type] = {}\n\n        myOwnDependents[property] = {\n          dispatched: false,\n          callback: (instance) => {\n            modulesContainer[type].injectDependency(property, instance)\n\n            let targetInstanceName = modulesContainer[type].impl.scope ? modulesContainer[type].impl.name : modulesContainer[type].impl.constructor.name\n            console.log('Dispatching an instance of ', instance.constructor.name, ' for ', targetInstanceName + '.' + property)\n          }\n        }\n      }\n    }\n  }\n\n  static dispatchDependents(type, dependents) {\n    for(let className in dependents) {\n      let classProperties = dependents[className]\n\n      for(let property in classProperties) {\n        let resolverCallbackInfo = classProperties[property]\n\n        modulesContainer[type].getInstance().then((instance) => {\n          if(!resolverCallbackInfo.dispatched) {\n            resolverCallbackInfo.callback(instance)\n            resolverCallbackInfo.dispatched = true\n          }\n        }).catch((err) => {\n          console.error('Error dispatching instance for the property', property)\n        })\n      }\n    }\n  }\n\n  static runInjectionResolver(type) {\n    // Resolve dependencies\n    ModuleContainer.resolveDependencies(type, modulesContainer[type].dependencies)\n\n    // Dispatch dependents registered dependents\n    ModuleContainer.dispatchDependents(type, modulesContainer[type].dependents)\n\n    // Wait for future dependents to be resolved\n    Object.observe(modulesContainer[type].dependents, (changes) => {\n      ModuleContainer.dispatchDependents(type, modulesContainer[type].dependents)\n    })\n  }\n\n  static addDependency(type, property, typeToInject) {\n    ModuleContainer.addInterface(type)\n    modulesContainer[type].dependencies[property] = typeToInject.name\n  }\n\n  static addImplementation(type, impl) {\n    if(ModuleContainer.validateImpl(type, impl)) {\n      modulesContainer[type.name].impl = (impl.scope === 'prototype') ? impl : new impl()\n      ModuleContainer.runInjectionResolver(type.name)\n    }\n  }\n\n  static addPostInjectMethod(type, methodName) {\n    modulesContainer[type].postInjectMethod = methodName\n  }\n\n  static getModuleContainer() {\n    return modulesContainer\n  }\n}\n"]}