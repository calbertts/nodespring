{"version":3,"sources":["../../src/core/ModuleContainer.js"],"names":[],"mappings":"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","file":"ModuleContainer.js","sourcesContent":["/**\n * ModuleContainer\n * @author calbertts\n *\n * This class handles all the stuff relates with:\n *\n *    Controllers and HTTP methods\n *    Dependency Injection\n */\n\nimport fs from 'fs'\nimport path_module from 'path'\nimport NodeSpringUtil from './NodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\n\nglobal.modulesContainer = {}\nlet modulesContainer = global.modulesContainer\n\nexport default class ModuleContainer {\n\n  static appDir = null\n  static implConfig = {}\n  static nodeSpringApp = {\n    bindURL: () => {},\n    addSocketListener: () => {},\n    addSocketListeners: () => {}\n  }\n\n  static init(appDir, nodeSpringApp, implConfig, logging = false, loggingSync = false, debugging = false) {\n    NodeSpringUtil.logging = logging\n    NodeSpringUtil.configureLoggingOut(loggingSync)\n    NodeSpringUtil.debugging = debugging\n\n    ModuleContainer.appDir = appDir\n    ModuleContainer.implConfig = implConfig\n    ModuleContainer.nodeSpringApp = nodeSpringApp || ModuleContainer.nodeSpringApp\n  }\n\n  static loadModules() {\n    let load = (path) => {\n      try {\n        let stat = fs.lstatSync(path)\n\n        if (stat.isDirectory()) {\n          let files = fs.readdirSync(path)\n          let f, l = files.length\n          for (let i = 0; i<l; i++) {\n            f = path_module.join(path, files[i])\n            load(f)\n          }\n        } else {\n          if(path_module.extname(path) === '.js') {\n            require(path)\n          }\n        }\n      } catch(e) {\n        throw new NodeSpringException(e.message, this)\n      }\n    }\n\n    let baseDir = path_module.join(ModuleContainer.appDir)\n    load(baseDir)\n\n    // All metadata is loaded except the injected instances\n    ModuleContainer.nodeSpringApp.configureSocketListeners()\n  }\n\n  static addService(moduleDef) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].impl.packagePath = moduleDef.packagePath\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.resolveDependencies(moduleName)\n  }\n\n  static addController(moduleDef, path, namespace) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n    modulesContainer[moduleName].path = path\n    modulesContainer[moduleName].impl = new moduleDef()\n    modulesContainer[moduleName].impl.packagePath = moduleDef.packagePath\n    modulesContainer[moduleName].moduleType = moduleDef.moduleType\n\n    ModuleContainer.resolveDependencies(moduleName)\n\n    let moduleInfo = modulesContainer[moduleName]\n\n    let processRequest = (req, res, methodInfo) => {\n      let fn = moduleInfo.impl[methodInfo.methodName]\n\n      ModuleContainer.nodeSpringApp.getRequestParams(req, (params) => {\n        let fullParams = NodeSpringUtil.getArgs(fn).map((item, index) => {\n          return params[item] || (params[item + '[]'] instanceof Array ? params[item + '[]'] : [params[item + '[]']])\n        })\n\n        let handleResponse = (data) => {\n          ModuleContainer.nodeSpringApp.setContentTypeResponse(res, methodInfo.contentType)\n\n          if(methodInfo.contentType === 'application/json') {\n            ModuleContainer.nodeSpringApp.sendJSONResponse(res, data)\n          } else {\n            ModuleContainer.nodeSpringApp.sendDataResponse(res, data)\n          }\n        }\n\n        // Getting method response\n        fn.request = req\n        fn.response = res\n        let value = fn.apply(moduleInfo.impl, fullParams)\n\n        // Clear\n        delete fn.request\n        delete fn.response\n\n        if(value !== undefined) {\n          if(value instanceof Promise) {\n            value\n              .then((data) => {\n                handleResponse(data)\n              })\n              .catch((err) => {\n                handleResponse(err)\n              })\n          } else {\n            handleResponse(value)\n          }\n        }\n      })\n    }\n\n    /**\n     * This metadata is created in addSocketListener method\n     */\n    ModuleContainer.nodeSpringApp.addSocketListeners(namespace, moduleInfo.socketListeners, moduleInfo.impl)\n\n    // Bind index method\n    ModuleContainer.nodeSpringApp.bindURL('get', `/${path}`, (req, res) => {\n      processRequest(req, res, {methodName: 'index'})\n    })\n\n    // Bind the other endpoints\n    moduleInfo.methods.forEach((methodInfo) => {\n      ModuleContainer.nodeSpringApp.bindURL(methodInfo.httpMethod, `/${path}/${methodInfo.methodName}`, (req, res) => {\n        processRequest(req, res, methodInfo)\n      })\n    })\n  }\n\n  static addRoute(moduleDef, methodName, httpMethod, contentType) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n\n    modulesContainer[moduleName].methods.push({\n      methodName: methodName,\n      httpMethod: httpMethod,\n      contentType: contentType\n    })\n  }\n\n  static addSocketListener(moduleDef, methodName, options) {\n    let moduleName = moduleDef.packagePath\n\n    ModuleContainer.addInterface(moduleName)\n\n    modulesContainer[moduleName].socketListeners.push({\n      methodName: methodName,\n      eventName: options.eventName ? options.eventName : methodName\n    })\n  }\n\n  static validateImpl(type, impl) {\n    ModuleContainer.addInterface(type.packagePath)\n\n    let interfaceMethods = Object.getOwnPropertyNames(type.prototype)\n    let implementationMethods = Object.getOwnPropertyNames(impl.prototype)\n\n    interfaceMethods.filter((methodName) => {\n      return methodName !== 'constructor'\n    }).forEach(methodName => {\n      let isMethodImplemented = implementationMethods.indexOf(methodName) >= 0\n\n      if (!isMethodImplemented) {\n        let errorMessage = `The method \"${methodName}\" declared in ${type.packagePath} is not implemented in ${impl.name}`\n        let methodNotImplemented = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n        NodeSpringUtil.throwNodeSpringException(methodNotImplemented)\n      } else {\n        NodeSpringUtil.getArgs(type.prototype[methodName]).forEach((param) => {\n          let implMethodParams = NodeSpringUtil.getArgs(impl.prototype[methodName])\n          let isParamPresent = implMethodParams.indexOf(param) >= 0\n\n          if (!isParamPresent) {\n            let errorMessage = `The param \"${param}\" declared in ${type.packagePath}.${methodName}(...) is not present in ${impl.name}.${methodName}(...)`\n            let missingParam = new NodeSpringException(errorMessage, ModuleContainer.addImplementation, 1)\n\n            NodeSpringUtil.throwNodeSpringException(missingParam)\n          }\n        })\n      }\n    })\n\n    return true\n  }\n\n  static addInterface(type) {\n    if (modulesContainer[type] === undefined) {\n      modulesContainer[type] = {\n        impl: null,\n        dependencies: {},\n        methods: [],\n        socketListeners: [],\n        postInjectMethodExecuted: false,\n        getInstance: () => {\n          return ModuleContainer.resolveDependencies(type)\n        }\n      }\n    }\n  }\n\n  static resolveDependencies(type) {\n    let moduleInfo = modulesContainer[type]\n    let dependencies = moduleInfo.dependencies\n\n    if (modulesContainer[type].impl && Object.keys(dependencies).length > 0) {\n      let dependenciesInstancesPromises = []\n      let mapImplVariable = {}\n\n      for(let property in dependencies) {\n        let moduleNeeded = dependencies[property]\n        let promise = modulesContainer[moduleNeeded].getInstance()\n\n        mapImplVariable[moduleNeeded] = property\n\n        dependenciesInstancesPromises.push(promise)\n      }\n\n      return new Promise((resolve, reject) => {\n\n        /**\n         * Wait for the dependencies are resolved to be injected\n         * in the instance that's being created\n         */\n\n        Promise.all(dependenciesInstancesPromises).then((instances) => {\n\n          let mainInstance = modulesContainer[type].impl.scope === 'prototype' ? new modulesContainer[type].impl() : modulesContainer[type].impl\n\n          instances.forEach((instanceToInject) => {\n            let varType = instanceToInject.constructor.interfacePackagePath || instanceToInject.packagePath\n            let property = mapImplVariable[varType]\n\n            mainInstance[property] = instanceToInject\n          })\n\n          // Call the init method once all the dependencies are created and injected\n          let postInjectMethod = modulesContainer[type].postInjectMethod\n\n          if(postInjectMethod && !modulesContainer[type].postInjectMethodExecuted) {\n            modulesContainer[type].postInjectMethodExecuted = true\n            mainInstance[postInjectMethod]()\n\n            delete modulesContainer[type].postInjectMethod\n          }\n\n          // Resolve the complete instance to the modules which are waiting for it\n          resolve(mainInstance)\n        }).catch((err) => {\n          NodeSpringUtil.error('Error resolving instance for', type, err)\n          reject(err)\n        })\n      })\n    } else {\n\n      /**\n       * If the module doesn't have dependencies, returns the impl if it's loaded or\n       * will wait for the implementation that is loaded to dispatch the instance.\n       */\n\n      return new Promise((resolve, reject) => {\n        if(modulesContainer[type].impl) {\n          if(modulesContainer[type].impl.scope) {\n            if(modulesContainer[type].impl.scope === 'singleton') {\n              resolve(modulesContainer[type].impl)\n            }\n            else if(modulesContainer[type].impl.scope === 'prototype')\n              resolve(new modulesContainer[type].impl())\n          } else {\n            resolve(modulesContainer[type].impl)\n          }\n        } else {\n          Object.observe(modulesContainer[type], (changes) => {\n            let change = changes.filter((change) => change.type === 'update')[0]\n\n            if(Object.keys(modulesContainer[type].dependencies).length > 0) {\n              modulesContainer[type].getInstance().then((instance) => {\n                resolve(instance)\n              })\n            } else {\n              resolve(!modulesContainer[type].impl.scope ? modulesContainer[type].impl : new modulesContainer[type].impl())\n            }\n          })\n        }\n      })\n    }\n  }\n\n  static addDependency(type, property, typeToInject) {\n    ModuleContainer.addInterface(type)\n    modulesContainer[type].dependencies[property] = typeToInject.packagePath\n  }\n\n  static addImplementation(type, impl) {\n    if(ModuleContainer.validateImpl(type, impl)) {\n      modulesContainer[type.packagePath].impl = (impl.scope === 'prototype') ? impl : new impl()\n      ModuleContainer.resolveDependencies(type.packagePath)\n    }\n  }\n\n  static addPostInjectMethod(type, methodName) {\n    ModuleContainer.addInterface(type)\n    modulesContainer[type].postInjectMethod = methodName\n  }\n\n  static getModuleContainer() {\n    return modulesContainer\n  }\n}\n"]}