{"version":3,"sources":["../../src/decorators/dependencyManagement.js"],"names":[],"mappings":";;;;;QAUgB;QAeA;QAgBA;QAWA;;;;AA5ChB,OAAO,WAAP,GAAqB,IAArB;;;;;;AAEO,SAAS,MAAT,CAAgB,YAAhB,EAA8B;;;;AAInC,SAAO,UAAC,MAAD,EAAS,QAAT,EAAmB,UAAnB,EAAkC;AACvC,eAAW,QAAX,GAAsB,IAAtB,CADuC;;AAGvC,QAAI,aAAa,OAAO,WAAP,GAAqB,OAAO,WAAP,CAAmB,IAAnB,GAA0B,OAAO,WAAP,CAAmB,IAAnB;;;;AAHzB,oCAOvC,CAAgB,aAAhB,CAA8B,UAA9B,EAA0C,QAA1C,EAAoD,YAApD,EAPuC;GAAlC,CAJ4B;CAA9B;;AAeA,SAAS,UAAT,CAAoB,IAApB,EAA0B;AAC/B,SAAO,WAAP,GAAqB,IAArB;;;;AAD+B,SAKxB,UAAC,MAAD,EAAS,QAAT,EAAmB,UAAnB,EAAkC;;AAEvC,WAAO,aAAP,GAAuB,KAAK,IAAL,CAFgB;AAGvC,WAAO,UAAP,GAAoB,gBAApB,CAHuC;;AAKvC,WAAO,WAAP,GAAqB,IAArB,CALuC;;AAOvC,qCAAgB,iBAAhB,CAAkC,IAAlC,EAAwC,MAAxC,EAPuC;GAAlC,CALwB;CAA1B;;AAgBA,SAAS,SAAT,CAAmB,aAAnB,EAAkC;AACvC,MAAI,iBAAiB,UAAU,CAAV,CAAjB,CADmC;AAEvC,gBAAc,UAAd,GAA2B,WAA3B;;;;;;AAFuC,SAQhC,eAAe,SAAf,CAAyB,WAAzB,CARgC;CAAlC;;AAWA,SAAS,UAAT,CAAoB,MAApB,EAA4B,QAA5B,EAAsC,UAAtC,EAAkD;AACvD,mCAAgB,mBAAhB,CAAoC,OAAO,WAAP,CAAmB,IAAnB,EAAyB,QAA7D,EADuD;CAAlD","file":"dependencyManagement.js","sourcesContent":["/**\r\n * Dependency Management\r\n *\r\n * @author calbertts\r\n */\r\n\r\nimport {ModuleContainer} from '../core/moduleContainer'\r\n\r\nglobal.implContext = null\r\n\r\nexport function Inject(typeToInject) {\r\n\r\n  //console.log('analizing dependency', typeToInject.name, ' for ', global.implContext ? global.implContext.name : 'bad')\r\n\r\n  return (target, property, descriptor) => {\r\n    descriptor.writable = true\r\n\r\n    let targetName = global.implContext ? global.implContext.name : target.constructor.name\r\n\r\n    //console.log('executing dependency', typeToInject.name, ' for ', targetName)\r\n\r\n    ModuleContainer.addDependency(targetName, property, typeToInject)\r\n  }\r\n}\r\n\r\nexport function Implements(type) {\r\n  global.implContext = type\r\n\r\n  //console.log('analizing implementation', type.name)\r\n\r\n  return (target, property, descriptor) => {\r\n    //console.log('executing implementation', type.name, ' for ', target.name)\r\n    target.interfaceName = type.name\r\n    target.moduleType = 'implementation'\r\n\r\n    global.implContext = null\r\n\r\n    ModuleContainer.addImplementation(type, target)\r\n  }\r\n}\r\n\r\nexport function Interface(interfaceBase) {\r\n  let interfaceClass = arguments[0]\r\n  interfaceBase.moduleType = 'interface'\r\n\r\n  /*interfaceClass.prototype.constructor = new Function(interfaceClass.name, \" return function \" + interfaceClass.name + \"(){ \"+\r\n    \"throw TypeError('NodeSpring Error: Cannot construct \"+interfaceClass.name+\" instances directly, because it is an Interface')}\")\r\n  ()*/\r\n\r\n  return interfaceClass.prototype.constructor\r\n}\r\n\r\nexport function PostInject(target, property, descriptor) {\r\n  ModuleContainer.addPostInjectMethod(global.implContext.name, property)\r\n}"]}