{"version":3,"sources":["../../src/decorators/dependencyManagement.js"],"names":[],"mappings":"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","file":"dependencyManagement.js","sourcesContent":["/**\n * Dependency Management\n * @author calbertts\n */\n\nimport ModuleContainer from '../core/ModuleContainer'\nimport path from 'path'\nimport Abstract from '../core/Abstract'\nimport NodeSpringUtil from '../core/NodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\nimport util from 'util'\n\n\nglobal.implContext = null\n\n\n/**\n * Enumeration to specify the scope type for implementations\n * @type {{SINGLETON: string, PROTOTYPE: string}}\n */\nexport var Scope = {\n  SINGLETON: 'singleton',\n  PROTOTYPE: 'prototype'\n}\n\n\n/**\n * Decorator to inject a dependency using an interface\n * @param typeToInject\n * @returns {Function}\n * @constructor\n */\nexport function Inject(typeToInject) {\n  if(!typeToInject || !NodeSpringUtil.isClass(typeToInject)) {\n    throw new NodeSpringException('@Inject expects an Interface but an ' + typeToInject + ' was received.', this, 2)\n  }\n\n  let basePackagePath = path.dirname(NodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n\n  return (target, property, descriptor) => {\n    let packagePath = basePackagePath + '/' + target.constructor.name\n\n    descriptor.writable = true\n\n    let targetName = global.implContext ? global.implContext.packagePath : packagePath\n    let preConfiguredImpl = ModuleContainer.implConfig[targetName]\n\n    //NodeSpringUtil.debug('inject:', targetName)\n\n    if(preConfiguredImpl) {\n      if(path.basename(packagePath) !== path.basename(preConfiguredImpl)) {\n        NodeSpringUtil.error('Ignored implementation from @Inject ' + packagePath)\n        return\n      }\n    }\n\n    if(typeToInject.moduleType === 'controller') {\n      throw new TypeError('You cannot inject a Controller as a dependency, please take a look on ' + targetName)\n    }\n\n    ModuleContainer.addDependency(targetName, property, typeToInject)\n  }\n}\n\n\n/**\n * Decorator to specify when a class implements a specific interface\n * @param type\n * @param scope\n * @returns {Function}\n * @constructor\n */\nexport function Implements(type, scope = Scope.SINGLETON) {\n  if(!type || !NodeSpringUtil.isClass(type)) {\n    throw new NodeSpringException('@Implements expects a Class but an ' + type + ' was received.', this, 2)\n  }\n\n  if(scope !== Scope.SINGLETON && scope !== Scope.PROTOTYPE) {\n    throw new NodeSpringException('Invalid Scope for ' + type.name + ', ' + scope + ' was received', this, 2)\n  }\n\n  global.implContext = type\n\n  return (target, property, descriptor) => {\n    target.scope = scope\n    target.interfaceName = type.name\n    target.interfacePackagePath = type.packagePath\n    target.moduleType = 'implementation'\n\n    global.implContext = null\n\n    let preConfiguredImpl = ModuleContainer.implConfig[type.packagePath]\n\n    if(preConfiguredImpl) {\n      if(target.name !== path.basename(preConfiguredImpl)) {\n        NodeSpringUtil.error('Ignored implementation from @Implements ' + target.name)\n        return\n      }\n    }\n\n    ModuleContainer.addImplementation(type, target)\n  }\n}\n\n\n/**\n * Decorator to specify a class is an interface\n * @param interfaceBase\n * @returns {MockedInterface}\n * @constructor\n */\nexport function Interface(interfaceBase) {\n  if(!interfaceBase || !NodeSpringUtil.isClass(interfaceBase)) {\n    throw new NodeSpringException('@Interface expects a Class but an ' + interfaceBase + ' was received.', this, 2)\n  }\n\n  let basePackagePath = path.dirname(NodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n  let packagePath = basePackagePath + '/' + interfaceBase.name\n\n  ModuleContainer.addInterface(packagePath)\n\n  class MockedInterface extends Abstract {\n    static moduleType = 'interface'\n    static packagePath = packagePath\n\n    constructor() {\n      super()\n    }\n  }\n\n  Object.defineProperty(MockedInterface, 'name', {\n    value: interfaceBase.name,\n    configurable: true\n  })\n\n  let interfaceMethods = Object.getOwnPropertyNames(interfaceBase.prototype)\n\n  interfaceMethods.filter((methodName) => {\n    return methodName !== 'constructor'\n  }).forEach((method) => {\n    if(method === 'getInstance')\n      throw new NodeSpringException('getInstance(...) is a reserved method for Interfaces, try with other name on ' + interfaceBase.name, this, 2)\n\n    MockedInterface.prototype[method] = interfaceBase.prototype[method]\n  })\n\n  MockedInterface.getInstance = () => {\n    return modulesContainer[packagePath].getInstance()\n  }\n\n  return MockedInterface\n}\n\n\n/**\n * Decorator to indicate a method which must be called after all dependencies are injected\n * @param target\n * @param property\n * @param descriptor\n * @constructor\n */\nexport function PostInject(target, property, descriptor) {\n  let basePackagePath = path.dirname(NodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', ''))\n  let packagePath = basePackagePath + '/' + target.constructor.name\n  let targetName = global.implContext ? global.implContext.packagePath : packagePath\n\n  ModuleContainer.addPostInjectMethod(targetName, property)\n}\n"]}