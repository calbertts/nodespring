{"version":3,"sources":["../../src/decorators/dependencyManagement.js"],"names":[],"mappings":"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","file":"dependencyManagement.js","sourcesContent":["/**\n * Dependency Management\n * @author calbertts\n */\n\nimport ModuleContainer from '../core/ModuleContainer'\nimport path from 'path'\nimport Abstract from '../core/Abstract'\nimport NodeSpringUtil from '../core/NodeSpringUtil'\nimport NodeSpringException from '../exceptions/NodeSpringException'\nimport util from 'util'\n\n\nglobal.implContext = null\n\n\n/**\n * Enumeration to specify the scope type for implementations\n * @type {{SINGLETON: string, PROTOTYPE: string}}\n */\nexport var Scope = {\n  SINGLETON: 'singleton',\n  PROTOTYPE: 'prototype'\n}\n\n\n/**\n * Decorator to inject a dependency using an interface\n * @param typeToInject\n * @returns {Function}\n * @constructor\n */\nexport function Inject(typeToInject) {\n\n  let packagePath = NodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', '')\n\n  return (target, property, descriptor) => {\n    descriptor.writable = true\n\n    let targetName = global.implContext ? global.implContext.packagePath : packagePath\n    let preConfiguredImpl = ModuleContainer.implConfig[targetName]\n\n    //NodeSpringUtil.log('inject:', targetName)\n\n    if(preConfiguredImpl) {\n      if(path.basename(packagePath) !== path.basename(preConfiguredImpl)) {\n        console.error('Ignored implementation from @Inject ' + packagePath)\n        return\n      }\n    }\n\n    if(typeToInject.moduleType === 'controller') {\n      throw new TypeError('You cannot inject a Controller as a dependency, please take a look on ' + targetName)\n    }\n\n    ModuleContainer.addDependency(targetName, property, typeToInject)\n  }\n}\n\n\n/**\n * Decorator to specify when a class implements a specific interface\n * @param type\n * @param scope\n * @returns {Function}\n * @constructor\n */\nexport function Implements(type, scope = Scope.SINGLETON) {\n  global.implContext = type\n\n  //NodeSpringUtil.log('Impl context:', type.packagePath)\n\n  return (target, property, descriptor) => {\n    target.scope = scope\n    target.interfaceName = type.name\n    target.interfacePackagePath = type.packagePath\n    target.moduleType = 'implementation'\n\n    global.implContext = null\n\n    //NodeSpringUtil.log('implements:', target.name)\n\n    //NodeSpringUtil.log('type.packagePath', type.packagePath)\n    //NodeSpringUtil.log('preConfiguredImpl', ModuleContainer.implConfig)\n\n    let preConfiguredImpl = ModuleContainer.implConfig[type.packagePath]\n\n    //NodeSpringUtil.log('..preConfiguredImpl', preConfiguredImpl)\n    //NodeSpringUtil.log('target.name', target.name)\n\n    //NodeSpringUtil.log(target.name, '!==', path.basename(preConfiguredImpl))\n\n    if(preConfiguredImpl) {\n      if(target.name !== path.basename(preConfiguredImpl)) {\n        NodeSpringUtil.error('Ignored implementation from @Implements ' + target.name)\n        return\n      }\n    }\n\n    /*let interfaceMethods = Object.getOwnPropertyNames(type.prototype)\n    let implMethods = Object.getOwnPropertyNames(target.prototype)\n\n    class ImplementationWrapper {\n      //impl = new target()\n\n      static scope = scope\n      static interfaceName = type.name\n      static interfacePackagePath = type.packagePath\n      static moduleType = 'implementation'\n    }\n\n    implMethods.forEach((implMethod) => {\n      if(interfaceMethods.indexOf(implMethod) < 0 && implMethod !== 'init') {\n        let exceptionFn = () => {\n          let stack = NodeSpringUtil.getStack()\n          console.log(stack);\n          let methodNotDeclared = new NodeSpringException('The method \"' + implMethod + '\", is not declared on the interface \"' + type.name + '\", so you cannot call it from here', this, 2)\n          NodeSpringUtil.throwNodeSpringException(methodNotDeclared)\n        }\n\n        Object.defineProperty(exceptionFn, 'name', {\n          value: implMethod,\n          configurable: true\n        })\n\n        ImplementationWrapper.prototype[implMethod] = exceptionFn\n      } else {\n        console.log('ARGS:', NodeSpringUtil.getArgs(target.prototype[implMethod]))\n\n        let fnArgs = NodeSpringUtil.getArgs(target.prototype[implMethod])\n\n        let s = Symbol('type')\n\n        ImplementationWrapper.prototype[implMethod] = (s) => {\n          return target.prototype[implMethod].apply(this, arguments)\n        }\n\n        ImplementationWrapper.prototype[implMethod] = target.prototype[implMethod]\n      }\n    })\n\n    //console.log('target', target.prototype)\n    //console.log('ImplementationWrapper', ImplementationWrapper.prototype)*/\n\n    ModuleContainer.addImplementation(type, target)\n  }\n}\n\n\n/**\n * Decorator to specify a class is an interface\n * @param interfaceBase\n * @returns {MockedInterface}\n * @constructor\n */\nexport function Interface(interfaceBase) {\n  console.log('STARTING INTERFACE', interfaceBase.name)\n  let packagePath = NodeSpringUtil.getStack().replace(ModuleContainer.appDir, '').replace('.js', '')\n\n  //NodeSpringUtil.log('packagePath', packagePath)\n  //sNodeSpringUtil.log('interface:', interfaceBase.name)\n\n  class MockedInterface extends Abstract {\n    static moduleType = 'interface'\n    static packagePath = packagePath\n\n    constructor() {\n      super()\n    }\n  }\n\n  Object.defineProperty(MockedInterface, 'name', {\n    value: interfaceBase.name,\n    configurable: true\n  })\n\n  let interfaceMethods = Object.getOwnPropertyNames(interfaceBase.prototype)\n\n  interfaceMethods.filter((methodName) => {\n    return methodName !== 'constructor'\n  }).forEach((method) => {\n    MockedInterface.prototype[method] = interfaceBase.prototype[method]\n  })\n\n  return MockedInterface\n}\n\n\n/**\n * Decorator to indicate a method which must be called after all dependencies are injected\n * @param target\n * @param property\n * @param descriptor\n * @constructor\n */\nexport function PostInject(target, property, descriptor) {\n  ModuleContainer.addPostInjectMethod(global.implContext.packagePath, property)\n}\n"]}