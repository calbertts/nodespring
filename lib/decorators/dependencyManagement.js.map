{"version":3,"sources":["../../src/decorators/dependencyManagement.js"],"names":[],"mappings":";;;;;;QAUgB;QAeA;QAcA;QAWA;;;;;;;;AA1ChB,OAAO,WAAP,GAAqB,IAArB;;;;;AAEO,SAAS,MAAT,CAAgB,YAAhB,EAA8B;;AAEnC,SAAO,UAAC,MAAD,EAAS,QAAT,EAAmB,UAAnB,EAAkC;AACvC,eAAW,QAAX,GAAsB,IAAtB,CADuC;;AAGvC,QAAI,aAAa,OAAO,WAAP,GAAqB,OAAO,WAAP,CAAmB,IAAnB,GAA0B,OAAO,WAAP,CAAmB,IAAnB,CAHzB;;AAKvC,QAAG,aAAa,UAAb,KAA4B,YAA5B,EAA0C;AAC3C,YAAM,IAAI,SAAJ,CAAc,2EAA2E,UAA3E,CAApB,CAD2C;KAA7C;;AAIA,8BAAgB,aAAhB,CAA8B,UAA9B,EAA0C,QAA1C,EAAoD,YAApD,EATuC;GAAlC,CAF4B;CAA9B;;AAeA,SAAS,UAAT,CAAoB,IAApB,EAA+C;MAArB,8DAAQ,2BAAa;;AACpD,SAAO,WAAP,GAAqB,IAArB,CADoD;;AAGpD,SAAO,UAAC,MAAD,EAAS,QAAT,EAAmB,UAAnB,EAAkC;AACvC,WAAO,KAAP,GAAe,KAAf,CADuC;AAEvC,WAAO,aAAP,GAAuB,KAAK,IAAL,CAFgB;AAGvC,WAAO,UAAP,GAAoB,gBAApB,CAHuC;;AAKvC,WAAO,WAAP,GAAqB,IAArB,CALuC;;AAOvC,8BAAgB,iBAAhB,CAAkC,IAAlC,EAAwC,MAAxC,EAPuC;GAAlC,CAH6C;CAA/C;;AAcA,SAAS,SAAT,CAAmB,aAAnB,EAAkC;AACvC,MAAI,iBAAiB,UAAU,CAAV,CAAjB,CADmC;AAEvC,gBAAc,UAAd,GAA2B,WAA3B;;;;;;AAFuC,SAQhC,eAAe,SAAf,CAAyB,WAAzB,CARgC;CAAlC;;AAWA,SAAS,UAAT,CAAoB,MAApB,EAA4B,QAA5B,EAAsC,UAAtC,EAAkD;AACvD,4BAAgB,mBAAhB,CAAoC,OAAO,WAAP,CAAmB,IAAnB,EAAyB,QAA7D,EADuD;CAAlD;;AAIA,IAAI,wBAAQ;AACjB,aAAW,WAAX;AACA,aAAW,WAAX;CAFS","file":"dependencyManagement.js","sourcesContent":["/**\n * Dependency Management\n * @author calbertts\n */\n\nimport ModuleContainer from '../core/moduleContainer'\n\n\nglobal.implContext = null\n\nexport function Inject(typeToInject) {\n\n  return (target, property, descriptor) => {\n    descriptor.writable = true\n\n    let targetName = global.implContext ? global.implContext.name : target.constructor.name\n\n    if(typeToInject.moduleType === 'controller') {\n      throw new TypeError('You cannot inject a Controller as a dependency, please take a look on ' + targetName)\n    }\n\n    ModuleContainer.addDependency(targetName, property, typeToInject)\n  }\n}\n\nexport function Implements(type, scope = 'singleton') {\n  global.implContext = type\n\n  return (target, property, descriptor) => {\n    target.scope = scope\n    target.interfaceName = type.name\n    target.moduleType = 'implementation'\n\n    global.implContext = null\n\n    ModuleContainer.addImplementation(type, target)\n  }\n}\n\nexport function Interface(interfaceBase) {\n  let interfaceClass = arguments[0]\n  interfaceBase.moduleType = 'interface'\n\n  /*interfaceClass.prototype.constructor = new Function(interfaceClass.name, \" return function \" + interfaceClass.name + \"(){ \"+\n    \"throw TypeError('NodeSpring Error: Cannot construct \"+interfaceClass.name+\" instances directly, because it is an Interface')}\")\n  ()*/\n\n  return interfaceClass.prototype.constructor\n}\n\nexport function PostInject(target, property, descriptor) {\n  ModuleContainer.addPostInjectMethod(global.implContext.name, property)\n}\n\nexport var Scope = {\n  SINGLETON: 'singleton',\n  PROTOTYPE: 'prototype'\n}"]}